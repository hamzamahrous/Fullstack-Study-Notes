In C# there's no multiple inheritance but we can do this by using **interfaces**.

To achieve **Inheritance** in C# you can use the syntax `class Dog: Animal`

If you want to prevent a class from being inherited from it you can use the keyword **sealed** .. and you should do this with any class you aren't planning to inherit from it as this will **increase the performance**.

If you want to make override for a method you should add the keyword **virtual** before it in the base class and then in the derived classes you add the keyword **override**.

When a child class is created, it needs to build the parent part first.  
`: base(name)` tells the child class **how to call the parent constructor**.

```Csharp
public class Animal{
    public string Name { get; set; }

    public Animal(string name){
        Name = name;
    }

    // Virtual method: allows overriding in child classes
    public virtual void Speak(){
        Console.WriteLine("The animal makes a sound.");
    }
}

public class Dog : Animal{
    public Dog(string name) : base(name){}

    // Override
    public override void Speak(){
        Console.WriteLine($"{Name} says: Woof!");
    }
}
```
***
**Polymorphism** means the same reference (same type) can point to different objects, and each object can behave differently when you call the same method.

```Csharp
Animal dog = new Dog();
Aniaml cat = new Cat();

dog.Speak();   // Dog version runs
cat.Speak();   // Cat version runs
```

And this was the first type of polymorphism **Dynamic Polymorphism** or **Run-time Polymorphism** .. so this achieved here in OOP by doing the same type `Aniaml` and depending on the object the behavior will be determined at the run-time.

Note that the polymorphism or dynamic polymorphism is just a concept and **can be achieved using interfaces or abstract classes**.

There's another type of polymorphism which is **static polymorphism** which can be done by **method overloading** and it's **called static because it's determined at the compile time**.